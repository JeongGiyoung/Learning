-- DISTINCT() : 결과 출력시 중복 방지

-- WHERE 절 : 조건문

-- ORDER BY ASC : 오름차순

-- ORDER BY DESC : 내림차순

-- WHERE 컬럼명 IN() : 컬럼값 중에 괄호 안에 값을 포함하면

-- WHERE 컬럼명 NOT IN() : 컬럼값 중에 괄호 안에 값을 포함하지 않으면

-- Base_table.sql 파일을 보면서 테이블 정의서, ERD 만들어 보기

-- BETWEEN : 이상, 이하 비교연산자

-- NOT BETWEEN
-- LIKE 

-- || : 문자열을 연결하는 결합 연산자

-- CONCAT( , ) : 두 문자열을 연결하여 반환

-- LOWER, UPPER, INITCAP

-- LTRIM, RTRIM : 공백제거

-- SUBSTR : 문자열 자르는 함수

-- ROUND

-- MOD : 나눈 나머지 값

-- SYSDATE

-- ADD_MONTHS 

-- NEXT_DAY, LAST_DAY

-- 이번 달이 며칠이 남았는지 검색

-- EXTRACT : 날짜에서 필요한 부분만 추출

-- 생일 3월인 회원을 검색

-- CAST() : 명시적으로 형 변환

-- (**매우 중요**) 
-- TO_CHAR(컬럼, '형태') : 숫자, 문자, 날짜 형식을 문자열로 변환
-- 9는 제시된 숫자에 실재하는 숫자에 대응.
-- 0은 제시된 숫자에 실재하지 않는 숫자에 대응.
-- L : 지역 화폐 기호, 
-- PR : 음수를 <> 괄호 표현

-- TO_NUMBER : 숫자형식의 문자열을 숫자로 반환

-- TO_DATE : 날짜형식의 문자열을 날짜로 반환

/*
AVG : 평균
[규칙]
일반컬럼과 그룹함수(AVG, MAX, MIN, SUM, COUNT 같은)를 같이 사용할 경우에는
꼭 Group By 절을 넣어 주어야 한다.
Group by 절에는 일반컬럼이 모두 들어가야 한다.
*/

-- COUNT()
-- COUNT(*) : 행의 개수를 센다.
-- COUNT() 는 Null 값은 제외하고 세기 때문에 다르다.

-- WHERE 절 : 일반조건으로만 사용
-- HAVING 절 : 그룹조건으로만 사용

-- NVL(컬럼 , 앞의 컬럼이 NULL이면 바꿔줄 값 )

-- NVL2(컬럼 ,앞의 컬럼이 NULL이면 바꿔줄 값 , NULL 아니면 바꿔줄 값 )

--[중요]
-- DECODE (컬럼,
	   컬럼값과 일치할 값 , 일치할 경우 바꿔줄 값,
                 컬럼값과 일치할 값 , 일치할 경우 바꿔줄 값,
	    일치하지 않을 경우 바꿔줄 값)

-- CASE WHEN 컬럼 조건문 
	THEN 조건에 해당하면 바꿔줄 값
	 ELSE 조건에 해당하지 않으면 바꿔줄 값
	END 

/*
EXISTS ()
IN 함수하고 기능은 거의 비슷하지만, 
IN은 조회되는 데이터가 많아서 조회시간이 길어진다.
그래서 IN은 권장되지 않는다.*/

SELECT prod_id, prod_name, prod_lgu
FROM prod
  WHERE EXISTS (SELECT lprod_gu
                        FROM lprod
                          WHERE lprod_gu = prod.prod_lgu
                                    AND lprod_gu = 'P301')

/* 
# SELECT * FROM lprod, prod : Cartesian Product / Cross Join 
  * 모든 데이터를 조합한다.
  * 경우의수가 매우 많아지는 상태를 초래하기 때문에 실무에서는 거의 쓰는 일이 없다.
*/

-- CROSS JOIN
-- 테이블에 별칭을 붙일 때는 'AS'를 쓰지 않는다.
--[국제표준방식(ANSI)] : 다른 DBMS 에서도 동일하게 사용

/* INNER JOIN
[Equi Join (Simple Join 혹은 Inner Join) ]
# 관계조건(PK, FK의 관계)식(조건식)이 필요하다
# Column명에는 Table명을 붙여야 한다.
# FROM으로 불러드리는 테이블 n개의 -1개만큼 WHERE 절에 조건식이 최소한 필요하다.
*/

--일반방식
SELECT A.prod_id "상품코드",
          A.prod_name "상품명",
          B.lprod_nm "분류명",
          C.buyer_name "거래처명"
FROM prod A, lprod B, buyer C
  WHERE A.prod_lgu = B.lprod_gu
            AND A.prod_buyer = C.buyer_id;
            
-- ANSI
SELECT A.prod_id "상품코드",
          A.prod_name "상품명",
          B.lprod_nm "분류명",
          C.buyer_name "거래처명"
FROM prod A INNER JOIN lprod B
                      ON (A.prod_lgu = B.lprod_gu)
                   INNER JOIN buyer C
                      ON (A.prod_buyer = C.buyer_id);

/* OUTER JOIN
# INNER JOIN의 경우 조건식(PK-FK 관계조건)을 만족하지 않는 데이터는 누락된다.
# 이런 누락된 데이터도 필요할 때 OUTER JOIN을 사용
# 일반방식 : (+) 연산자 기호가 붙어있는 쪽에서 NULL 이 있더라도 출력
  * FK 쪽에 (+) 가 붙는다.
    - PK 쪽에 (+)가 붙일 수는 있지만, 결과에 변화를 주지 않기 때문에 OUTER JOIN의 의미가 없다.
      + PK 테이블은  FK 테이블 컬럼을 모두 가지고 있기 때문
# 주로 LEFT OUTER JOIN 을 사용하지만 기준을 오른쪽에 두고 싶다면 RIGHT OUTER JOIN을 쓴다.
# 일반 방식에서 WHERE 절이 들어가면 OUTER JOIN 이 깨져버려서 OUTER JOIN을 사용할 때는 WHERE 절을 사용하지 않는다. */

SELECT prod_id,
          prod_name,
          SUM(buy_qty)
FROM lprod, buyprod
  WHERE lprod_gu = prod_lgu(+)
      AND buy_date BETWEEN 20050101 AND 20050131
    GROUP By lprod_gu, lprod_nm, buy_qty ;

-- ANSI
SELECT prod_id,
          prod_name,
          NVL(SUM(buy_qty),0) AS sum_buy
FROM prod LEFT OUTER JOIN buyprod
                        ON (prod_id = buy_prod
                              AND buy_date BETWEEN '2005-01-01' 
                                                        AND '2005-01-31')
GROUP BY prod_id, prod_name
ORDER BY prod_id, prod_name;



-- GROUP 함수를 사용한 경우에 추가 조건이 있다면 HAVING

/* [서브쿼리] 
# SQL 구문 안에 또다른 SELECT 구문이 있는 것.
# 가능하면 JOIN을 사용하고 JOIN 이 안될 때 사용
# ANY = 여러 값들 중 1개라도 참일 때
# ALL = 여러 값들 중 모두 참일 때
-
SELECT (1개 컬럼, 1개 행)
FROM (다중 컬럼, 다중 행)
  WHERE >= (1개 컬럼, 1개 행)
        IN (1개, 다중 행)
    EXIST (다중 컬럼, 다중 행
*/
###########################################
##########문제 
/* 회원 중에 김은대 회원이 지금까지 구매했던
모든 상품명을 조회해 주세요. */

/* [날짜 형식]
회원 중 생일 1975-01-01 에서 1976-12-31 사이에 태어난
회원을 검색한다.
(Alias는 회원ID, 회원 명, 생일) 
*/


/* 회원테이블의 주민등록번호 앞자리를 검색하여
1975년생을 제외한 회원을 검색한다.
Alias 회원ID, 성명, 주민등록번호 */

  
/* 회원테이블의 회원성명 중 성씨 '이' --> '리'로 치환하여
뒤에 이름을 붙인 후 검색한다.
Alias는 회원명, 회원명치환 */

/*
회원 생일 중 1973년생이 주로 구매한 상품을 오름차순으로 조회
- 조회 컬럼 : 상품명
- 단, 상품명에 삼성이 포함된 상품만 조회,
    그리고 조회결과 중복 제거
*/

/*
상품테이블에서 상품입고일을 '2008-09-28'형식으로 나오게 검색
Alias 상품명, 상품판매가, 입고일 */

/*
회원이름과 생일로 다음처럼 출력
'김은대님은 1976년 1월 출생이고 태어난 요일은 목요일'
*/

/* 
상품테이블에서 상품코드, 상품명, 매입가격, 소비자가격, 판매가격을 출력
단, 가격은 천단위 구분 및 원화표시
*/

/*  회원테이블에서 이쁜이 회원의
회원 ID 2~4 문자열을 숫자형으로 치환한 후
10을 더하여 새로운 회원 ID로 조합한다.
*/

-- 상품테이블의 상품분류별 판매가격 평균 값을 구한다.

/* 장바구니 테이블의 회원별 COUNT 집계
Alias는 회원 ID, 자료수(DISTINCT), 자료수, 자료수(*)
*/

/* 구매수량의 전체평균 이상을 구매한 회원들의
아이디와 이름을 조회
단, 정렬은 주민번호(앞)를 기준으로 오름차순*/



/* 
구매내역(장바구니) 정보에서 회원아이디별로 주문(수량)에 대한
평균을 조회
회원 아이디를 기준으로 내림차순
*/

/* [문제]
상품정보에서 판매가격의 평균 값을 구한다.
단, 평균값은 소수점 2째 자리까지 표현한다.
*/

/* [문제]
상품정보에서 상품분류별 판매가격의 평균값을 구한다.
조회 컬럼은 상품분류코드, 상품분류별 판매가격의 평균
단, 평균값은 소수점 2 번째 자리까지 표현
*/

/* [문제]
회원 전체의 마일리지 평균보다 큰 회원에 대한
아이디, 이름, 마일리지를 조회
마일리지가 높은 순으로 정렬
*/

/* [문제]
오늘이 2005년도 7월 11일이라 가정하고 
장바구니 테이블에 발생될 추가주문번호 검색
Alias 는 현재년월일 기준 가장 높은 주문번호, 추가주문번호
*/

/* [문제]
상품테이블에서 상품분류별 판매가 전체의
평균,합계,최고값, 최저값, 자료수를 검색
Alias 는 위에 제시된 대로
단, 자료수가 20개 이상인 것
*/

/* 회원 마일리지에 100을 더한 수치를 검색
 성명, 마일리지, 변경 마일리지
*/

/*[문제]
회원 마일리지가 있으면 '정상 회원' 
NULL이면 '비정상 회원'으로 검색
성명, 마일리지, 회원상태 조회
*/

/*[문제]
상품 분류 중 앞의 두 글자가 'P1'이면 판매가를 10% 인상하고,
'P2' 이면 판매가를 15%인상하고, 나머지는 동일 판매가로 검색
(DECODE 함수 이용, Alias 는 적절히)
*/

/* [문제]
회원정보테이블의 주민등록 뒷자리에서 
성별 구분 검색
(CASE 구문 사용, Alias 회원명, 주민등록번호, 성별)
*/

/*[문제]
회원이 구매한 거래처 정보를 조회
회원아이디, 회원이름, 상품거래처명, 상품분류명을 조회
*/
--일반방식
--ANSI 방식

/* [문제]
거래처가 '삼성전자'인 자료에 대한
상품코드, 상품명, 거래처명을 조회
*/

/* [문제]
상품테이블에서 상품코드, 상품명, 분류명, 거래처명, 거래처주소 조회
1) 판매가격이 10만원 이하이고
2) 거래처 주소가 부산인 경우만 조회
*/

/* [문제]
상품분류코드가 P101 인 것에 대한
상품분류명, 상품아이디, 판매가, 거래처담당자, 회원아이디, 주문수량 조회
단, 상품분류명을 기준으로 내림차순, 상품아이디를 기준으로 오름차순
일반/표준 방식 모두 표현
*/

/* 문제
상품분류명, 상품명, 상품색상, 매입수량, 주문수량, 거래처명을 조회
단, 상품분류 코드가 'P101', 'P201', 'P301' 인 것들에 대해 조회하고 
매입수량이 15개 이상인 것들과, 
'서울'에 살고 있는 회원 중에 생일 1974년 생인 사람들에 대해 조회
정렬은 회원아이디를 기준으로 내림차순, 매입수량을 기준으로 내림차순
*Join은 일반/표준방식 모두 작성
*/


/* 전체 분류의 상품자료 수를 검색
(분류코드, 분류명, 상품자료수) */

/* [문제]
전체상품의 2005년 1월 입고수량을 검색. null 값 제거
(상품코드, 상품명, 입고수량 조회) */

/* 일반 방식에서 WHERE 절이 들어가면 OUTER JOIN 이 깨져버려서 OUTER JOIN을 사용할 때는 WHERE 절을 사용하지 않는다. */

/* 전체 회원의 2005년도 4월의 구매현황 조회
(회원 ID, 성명, 구매수량의 합) */

/* 2005년도 월별 판매 현황 검색
(판매월, 판매수량, 판매금액(판매수량*상품테이블의 판매가))
*/


/* 상품분류가 컴퓨터제품('P101')인 상품의 2005년도 일자별 판매 조회
(판매일, 판매금액(5,000,000 초과의 경우만), 판매수량 조회)
*/
